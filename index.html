<!DOCTYPE html>
<html>
<head>
  <title>Machine Telemetry Table</title>
  <style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #f5f5f5;
    padding: 2rem;
    margin: 0;
    color: #333;
  }

  h2 {
    text-align: center;
    margin-bottom: 1.5rem;
    color: #222;
  }

  table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    background: #fff;
  }

  th, td {
    padding: 12px 14px;
    text-align: center;
    border-bottom: 1px solid #e0e0e0;
    cursor: pointer;
  }

  th {
    background-color: #f0f0f5;
    font-weight: 600;
    color: #444;
  }

  tbody tr:nth-child(even) {
    background-color: #f9f9fc;
  }

  tbody tr:hover {
    background-color: #eef3fb;
  }

  .bell {
    color: red;
    margin-left: 5px;
    font-size: 1.1em;
    cursor: pointer;
  }

  #error-box {
    color: red;
    margin-top: 1rem;
    text-align: center;
    font-weight: bold;
  }

  /* Modal styles */
  #trendModal {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.6);
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }

  #trendContent {
    background: #ffffff;
    padding: 2rem;
    border-radius: 12px;
    width: 90%;
    max-width: 650px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
  }

  #trendContent h3 {
    margin-top: 0;
    margin-bottom: 1rem;
    color: #222;
    font-size: 1.2rem;
  }

  #trendTable {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
  }

  #trendTable th, #trendTable td {
    border: 1px solid #ccc;
    padding: 10px;
    text-align: left;
  }

  #closeTrend {
    margin-top: 1.5rem;
    padding: 0.5rem 1rem;
    background-color: #007bff;
    color: white;
    font-weight: bold;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  }

  #closeTrend:hover {
    background-color: #0056b3;
  }

  /* NEW: alarm highlight & blink */
  .alarm {
    background-color: #ffe6e6 !important;
    color: #b30000;
    animation: blink 1s linear infinite;
    font-weight: 600;
  }
  @keyframes blink {
    50% { opacity: 0.25; }
  }
  </style>
</head>
<body>
  <h2>Machine Telemetry Table</h2>
  <table>
    <thead>
      <tr id="header-row">
        <th>Attribute</th>
        <th id="header-M1">Machine 1</th>
        <th id="header-M2">Machine 2</th>
        <th id="header-M3">Machine 3</th>
      </tr>
    </thead>
    <tbody>
      <!-- RENAMED attributes only -->
      <tr><td>Temperature</td><td id="M1_A1">--</td><td id="M2_A1">--</td><td id="M3_A1">--</td></tr>
      <tr><td>Pressure</td><td id="M1_A2">--</td><td id="M2_A2">--</td><td id="M3_A2">--</td></tr>
      <tr><td>Frequency</td><td id="M1_A3">--</td><td id="M2_A3">--</td><td id="M3_A3">--</td></tr>
    </tbody>
  </table>

  <div id="error-box"></div>

  <div id="trendModal">
    <div id="trendContent">
      <h3 id="trendTitle"></h3>
      <table id="trendTable">
        <thead><tr><th>Timestamp</th><th>Value</th></tr></thead>
        <tbody id="trendData"></tbody>
      </table>
      <button id="closeTrend">Close</button>
    </div>
  </div>

  <script>
    window.onload = function () {
      let jwt = null;
      const params = new URLSearchParams(window.location.search);
      jwt = params.get("token");

      const deviceId = "1e101ee0-5bd5-11f0-9d02-c191323b4da2";
      const baseUrl = "https://thingsboard.cloud";

      const machines = {
        "M1": ["M1_A1", "M1_A2", "M1_A3"],
        "M2": ["M2_A1", "M2_A2", "M2_A3"],
        "M3": ["M3_A1", "M3_A2", "M3_A3"]
      };

      // KEEP alarms object for minimal changes (used in popup URL), but we won't fetch those keys
      const alarms = {
        "M1": "M1_Alarm",
        "M2": "M2_Alarm",
        "M3": "M3_Alarm"
      };

      // Thresholds & deadband (A1=Temp, A2=Pressure, A3=Frequency)
      const thresholds = { A1: 60, A2: 35, A3: 50 };
      const deadband = 2; // points
      // Hysteresis per machine/param: track active state
      const paramAlarmState = {
        M1: { A1:false, A2:false, A3:false },
        M2: { A1:false, A2:false, A3:false },
        M3: { A1:false, A2:false, A3:false }
      };

      const bellAcknowledged = { M1: false, M2: false, M3: false };
      const alarmCounts = { M1: 0, M2: 0, M3: 0 }; // will show number of params currently in alarm
      const errorBox = document.getElementById("error-box");

      function paramIdFromKey(k) {
        // "M1_A2" -> "A2"
        const parts = k.split("_");
        return parts[1];
      }

      function hysteresisUpdate(isActive, value, thr, db) {
        if (!Number.isFinite(value)) return false;
        if (isActive) {
          // clear only when value < (thr - db)
          return !(value < (thr - db));
        } else {
          // trigger when value >= thr
          return (value >= thr);
        }
      }

      function reorderColumns(order, alarmValues) {
        const headerRow = document.getElementById("header-row");
        const newHeader = document.createElement("tr");
        newHeader.id = "header-row";
        newHeader.appendChild(Object.assign(document.createElement("th"), { innerText: "Attribute" }));

        order.forEach(machine => {
          const th = document.createElement("th");
          th.id = `header-${machine}`;
          const label = `Machine ${machine[1]}`;
          const countLabel = alarmCounts[machine] > 0 ? ` (Alarms = ${alarmCounts[machine]})` : "";
          th.innerText = label + countLabel;

          if (alarmValues[machine] && !bellAcknowledged[machine]) {
            const bell = document.createElement("span");
            bell.className = "bell";
            bell.innerText = "ðŸ””";
            bell.title = "Click to acknowledge";
            bell.onclick = e => {
              e.stopPropagation();
              bellAcknowledged[machine] = true;
              fetchTelemetry();
            };
            th.appendChild(bell);
          }

          newHeader.appendChild(th);
        });

        headerRow.replaceWith(newHeader);

        document.querySelectorAll("tbody tr").forEach((row, i) => {
          const newRow = document.createElement("tr");
          newRow.appendChild(row.children[0].cloneNode(true));
          order.forEach(m => {
            const id = machines[m][i];
            const old = document.getElementById(id);
            const cell = document.createElement("td");
            cell.id = id;
            cell.innerText = old?.innerText || "--";
            // preserve alarm highlight if present on old cell
            if (old && old.classList.contains('alarm')) cell.classList.add('alarm');
            newRow.appendChild(cell);
          });
          row.replaceWith(newRow);
        });

        function setupPopup() {
  const modal = document.getElementById("trendModal");
  const title = document.getElementById("trendTitle");
  const table = document.getElementById("trendData");
  const close = document.getElementById("closeTrend");

  document.querySelectorAll("td[id^='M']").forEach(cell => {
    cell.onclick = async () => {
      const key = cell.id;            // e.g., "M1_A1"
      const pid = key.split("_")[1];  // "A1" / "A2" / "A3"
      const thr = thresholds[pid];
      const db  = deadband;

      title.innerText = `${key} â€” last 10 values during alarm`;
      table.innerHTML = "";
      modal.style.display = "flex";

      const now = Date.now();
      const start = new Date().setHours(0, 0, 0, 0);
      const url = `${baseUrl}/api/plugins/telemetry/DEVICE/${deviceId}/values/timeseries?keys=${key}&startTs=${start}&endTs=${now}&limit=2000&agg=NONE`;

      try {
        const r = await fetch(url, { headers: { "X-Authorization": `Bearer ${jwt}` } });
        const data = await r.json();
        const vals = (data[key] || []).slice().sort((a,b)=>a.ts-b.ts);

        // Walk the series with the SAME hysteresis logic used on the live table:
        // - trigger when value >= thr
        // - clear when value < thr - db
        let active = false;
        const alarmSamples = [];
        for (const v of vals) {
          const num = Number(v.value);
          if (!Number.isFinite(num)) continue;
          const next = hysteresisUpdate(active, num, thr, db);
          active = next;
          if (active) alarmSamples.push({ ts: v.ts, value: num });
        }

        const last10 = alarmSamples.slice(-10).reverse(); // most recent first
        if (!last10.length) {
          table.innerHTML = "<tr><td colspan='2'>No alarm data today</td></tr>";
        } else {
          last10.forEach(s => {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td>${new Date(s.ts).toLocaleString()}</td><td>${s.value}</td>`;
            table.appendChild(tr);
          });
        }
      } catch (e) {
        table.innerHTML = "<tr><td colspan='2'>Error loading data</td></tr>";
        console.error("Trend fetch error:", e);
      }
    };
  });

  close.onclick = () => (modal.style.display = "none");
  modal.onclick = e => { if (e.target === modal) modal.style.display = "none"; };
}

      }

      // We won't compute historical alarm counts now; keep zeros for minimal change.
      async function fetchAlarmCounts() {
        alarmCounts.M1 = 0;
        alarmCounts.M2 = 0;
        alarmCounts.M3 = 0;
      }

      async function fetchTelemetry() {
        try {
          errorBox.innerText = "";
          await fetchAlarmCounts();

          // Only fetch machine keys (no M*_Alarm)
          const keys = [...Object.values(machines).flat()];
          const res = await fetch(`${baseUrl}/api/plugins/telemetry/DEVICE/${deviceId}/values/timeseries?keys=${keys.join(",")}`, {
            headers: { "X-Authorization": `Bearer ${jwt}` }
          });

          const data = await res.json();
          const alarmEntries = [], inactive = [];

          // Update cells, compute per-param alarm with hysteresis
          for (const m of ["M1", "M2", "M3"]) {
            let activeParamCount = 0;

            machines[m].forEach(k => {
              const el = document.getElementById(k);
              const latest = data[k]?.[0];
              let vText = "--";
              let val = NaN;

              if (latest) {
                const num = Number(latest.value);
                if (Number.isFinite(num)) {
                  val = num;
                  vText = num.toFixed(2);
                } else {
                  vText = latest.value; // keep string if not numeric
                }
              }

              if (el) {
                el.innerText = vText;

                // Determine threshold by param (A1/A2/A3)
                const pid = paramIdFromKey(k);
                const thr = thresholds[pid];
                if (thr != null) {
                  const prev = paramAlarmState[m][pid];
                  const next = hysteresisUpdate(prev, val, thr, deadband);
                  paramAlarmState[m][pid] = next;

                  // highlight if in alarm
                  if (next) {
                    el.classList.add('alarm');
                    activeParamCount++;
                  } else {
                    el.classList.remove('alarm');
                  }
                }
              }
            });

            // Maintain header "alarm count" = number of params currently in alarm
            alarmCounts[m] = activeParamCount;

            // Build active/inactive ordering for columns
            if (activeParamCount > 0) {
              alarmEntries.push({ machine: m, ts: Date.now() }); // keep order with active first
            } else {
              bellAcknowledged[m] = false; // reset acknowledge when all clear
              inactive.push(m);
            }
          }

          // Sort active machines (most recent first â€” here all use now)
          alarmEntries.sort((a, b) => b.ts - a.ts);
          const order = [...alarmEntries.map(a => a.machine), ...inactive];
          const activeMap = Object.fromEntries(alarmEntries.map(a => [a.machine, 1]));
          reorderColumns(order, activeMap);

        } catch (err) {
          console.error("Telemetry fetch error:", err);
          errorBox.innerText = "âš ï¸ Error fetching telemetry data";
        }
      }

function setupPopup() {
  const modal = document.getElementById("trendModal");
  const title = document.getElementById("trendTitle");
  const table = document.getElementById("trendData");
  const close = document.getElementById("closeTrend");
  const tbody = document.querySelector("tbody");

  // Bind once, survive row/column reorders
  if (!tbody._boundForAlarmPopup) {
    tbody.addEventListener("click", async (e) => {
      const cell = e.target.closest('td[id^="M"]');
      if (!cell) return;

      const key = cell.id;            // e.g., "M1_A1"
      const pid = key.split("_")[1];  // "A1" | "A2" | "A3"
      const thr = thresholds[pid];
      const db  = deadband;

      title.innerText = `${key} â€” last 10 values during alarm`;
      table.innerHTML = "";
      modal.style.display = "flex";

      const now = Date.now();
      const start = new Date().setHours(0, 0, 0, 0);
      const url = `${baseUrl}/api/plugins/telemetry/DEVICE/${deviceId}/values/timeseries?keys=${key}&startTs=${start}&endTs=${now}&limit=2000&agg=NONE`;

      try {
        const r = await fetch(url, { headers: { "X-Authorization": `Bearer ${jwt}` } });
        const data = await r.json();
        const vals = (data[key] || []).slice().sort((a,b)=>a.ts - b.ts);

        // Walk series with SAME hysteresis:
        // - trigger when value >= thr
        // - clear when value < thr - db
        let active = false;
        const alarmSamples = [];
        for (const v of vals) {
          const num = Number(v.value);
          if (!Number.isFinite(num)) continue;
          const next = hysteresisUpdate(active, num, thr, db);
          active = next;
          if (active) alarmSamples.push({ ts: v.ts, value: num });
        }

        const last10 = alarmSamples.slice(-10).reverse(); // most recent first
        if (!last10.length) {
          table.innerHTML = "<tr><td colspan='2'>No alarm data today</td></tr>";
        } else {
          const IST = { timeZone: 'Asia/Kolkata' };
          last10.forEach(s => {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td>${new Date(s.ts).toLocaleString('en-IN', IST)}</td><td>${s.value}</td>`;
            table.appendChild(tr);
          });
        }
      } catch (e2) {
        console.error("Trend fetch error:", e2);
        table.innerHTML = "<tr><td colspan='2'>Error loading data</td></tr>";
      }
    });
    tbody._boundForAlarmPopup = true;
  }

  close.onclick = () => (modal.style.display = "none");
  modal.onclick = (e) => { if (e.target === modal) modal.style.display = "none"; };
}


      fetchTelemetry();
      setInterval(fetchTelemetry, 10000);
    };
  </script>
</body>
</html>


